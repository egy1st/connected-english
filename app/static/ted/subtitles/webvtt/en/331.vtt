WEBVTT

00:00:00.000 --> 00:00:03.000
So, people argue vigorously about the definition of life.

00:00:03.000 --> 00:00:08.000
They ask if it should have reproduction in it, or metabolism, or evolution.

00:00:08.000 --> 00:00:10.000
And I don't know the answer to that, so I'm not going to tell you.

00:00:10.000 --> 00:00:13.000
I will say that life involves computation.

00:00:13.000 --> 00:00:15.000
So this is a computer program.

00:00:15.000 --> 00:00:18.000
Booted up in a cell, the program would execute,

00:00:18.000 --> 00:00:21.000
and it could result in this person;

00:00:21.000 --> 00:00:24.000
or with a small change, it could result in this person;

00:00:24.000 --> 00:00:26.000
or another small change, this person;

00:00:26.000 --> 00:00:29.000
or with a larger change, this dog,

00:00:29.000 --> 00:00:31.000
or this tree, or this whale.

00:00:31.000 --> 00:00:33.000
So now, if you take this metaphor

00:00:33.000 --> 00:00:35.000
[of] genome as program seriously,

00:00:35.000 --> 00:00:37.000
you have to consider that Chris Anderson

00:00:37.000 --> 00:00:40.000
is a computer-fabricated artifact, as is Jim Watson,

00:00:40.000 --> 00:00:43.000
Craig Venter, as are all of us.

00:00:43.000 --> 00:00:45.000
And in convincing yourself that this metaphor is true,

00:00:45.000 --> 00:00:47.000
there are lots of similarities between genetic programs

00:00:47.000 --> 00:00:50.000
and computer programs that could help to convince you.

00:00:50.000 --> 00:00:52.000
But one, to me, that's most compelling

00:00:52.000 --> 00:00:55.000
is the peculiar sensitivity to small changes

00:00:55.000 --> 00:00:58.000
that can make large changes in biological development -- the output.

00:00:58.000 --> 00:01:00.000
A small mutation can take a two-wing fly

00:01:00.000 --> 00:01:01.000
and make it a four-wing fly.

00:01:01.000 --> 00:01:05.000
Or it could take a fly and put legs where its antennae should be.

00:01:05.000 --> 00:01:07.000
Or if you're familiar with "The Princess Bride,"

00:01:07.000 --> 00:01:09.000
it could create a six-fingered man.

00:01:09.000 --> 00:01:11.000
Now, a hallmark of computer programs

00:01:11.000 --> 00:01:14.000
is just this kind of sensitivity to small changes.

00:01:14.000 --> 00:01:16.000
If your bank account's one dollar, and you flip a single bit,

00:01:16.000 --> 00:01:18.000
you could end up with a thousand dollars.

00:01:18.000 --> 00:01:21.000
So these small changes are things that I think

00:01:21.000 --> 00:01:23.000
that -- they indicate to us that a complicated computation

00:01:23.000 --> 00:01:27.000
in development is underlying these amplified, large changes.

00:01:27.000 --> 00:01:33.000
So now, all of this indicates that there are molecular programs underlying biology,

00:01:33.000 --> 00:01:37.000
and it shows the power of molecular programs -- biology does.

00:01:37.000 --> 00:01:39.000
And what I want to do is write molecular programs,

00:01:39.000 --> 00:01:41.000
potentially to build technology.

00:01:41.000 --> 00:01:42.000
And there are a lot of people doing this,

00:01:42.000 --> 00:01:45.000
a lot of synthetic biologists doing this, like Craig Venter.

00:01:45.000 --> 00:01:47.000
And they concentrate on using cells.

00:01:47.000 --> 00:01:49.000
They're cell-oriented.

00:01:49.000 --> 00:01:51.000
So my friends, molecular programmers, and I

00:01:51.000 --> 00:01:53.000
have a sort of biomolecule-centric approach.

00:01:53.000 --> 00:01:56.000
We're interested in using DNA, RNA and protein,

00:01:56.000 --> 00:01:59.000
and building new languages for building things from the bottom up,

00:01:59.000 --> 00:02:00.000
using biomolecules,

00:02:00.000 --> 00:02:03.000
potentially having nothing to do with biology.

00:02:03.000 --> 00:02:07.000
So, these are all the machines in a cell.

00:02:07.000 --> 00:02:09.000
There's a camera.

00:02:09.000 --> 00:02:10.000
There's the solar panels of the cell,

00:02:10.000 --> 00:02:12.000
some switches that turn your genes on and off,

00:02:12.000 --> 00:02:15.000
the girders of the cell, motors that move your muscles.

00:02:15.000 --> 00:02:17.000
My little group of molecular programmers

00:02:17.000 --> 00:02:21.000
are trying to refashion all of these parts from DNA.

00:02:21.000 --> 00:02:23.000
We're not DNA zealots, but DNA is the cheapest,

00:02:23.000 --> 00:02:26.000
easiest to understand and easy to program material to do this.

00:02:26.000 --> 00:02:28.000
And as other things become easier to use --

00:02:28.000 --> 00:02:31.000
maybe protein -- we'll work with those.

00:02:31.000 --> 00:02:33.000
If we succeed, what will molecular programming look like?

00:02:33.000 --> 00:02:35.000
You're going to sit in front of your computer.

00:02:35.000 --> 00:02:37.000
You're going to design something like a cell phone,

00:02:37.000 --> 00:02:39.000
and in a high-level language, you'll describe that cell phone.

00:02:39.000 --> 00:02:41.000
Then you're going to have a compiler

00:02:41.000 --> 00:02:42.000
that's going to take that description

00:02:42.000 --> 00:02:44.000
and it's going to turn it into actual molecules

00:02:44.000 --> 00:02:46.000
that can be sent to a synthesizer

00:02:46.000 --> 00:02:49.000
and that synthesizer will pack those molecules into a seed.

00:02:49.000 --> 00:02:52.000
And what happens if you water and feed that seed appropriately,

00:02:52.000 --> 00:02:54.000
is it will do a developmental computation,

00:02:54.000 --> 00:02:57.000
a molecular computation, and it'll build an electronic computer.

00:02:57.000 --> 00:02:59.000
And if I haven't revealed my prejudices already,

00:03:00.000 --> 00:03:02.000
I think that life has been about molecular computers

00:03:02.000 --> 00:03:04.000
building electrochemical computers,

00:03:04.000 --> 00:03:06.000
building electronic computers,

00:03:06.000 --> 00:03:08.000
which together with electrochemical computers

00:03:08.000 --> 00:03:10.000
will build new molecular computers,

00:03:10.000 --> 00:03:13.000
which will build new electronic computers, and so forth.

00:03:13.000 --> 00:03:14.000
And if you buy all of this,

00:03:14.000 --> 00:03:16.000
and you think life is about computation, as I do,

00:03:16.000 --> 00:03:19.000
then you look at big questions through the eyes of a computer scientist.

00:03:19.000 --> 00:03:23.000
So one big question is, how does a baby know when to stop growing?

00:03:23.000 --> 00:03:25.000
And for molecular programming,

00:03:25.000 --> 00:03:27.000
the question is how does your cell phone know when to stop growing?

00:03:27.000 --> 00:03:28.000
(Laughter)

00:03:28.000 --> 00:03:31.000
Or how does a computer program know when to stop running?

00:03:31.000 --> 00:03:34.000
Or more to the point, how do you know if a program will ever stop?

00:03:34.000 --> 00:03:36.000
There are other questions like this, too.

00:03:36.000 --> 00:03:38.000
One of them is Craig Venter's question.

00:03:38.000 --> 00:03:40.000
Turns out I think he's actually a computer scientist.

00:03:40.000 --> 00:03:43.000
He asked, how big is the minimal genome

00:03:43.000 --> 00:03:45.000
that will give me a functioning microorganism?

00:03:45.000 --> 00:03:47.000
How few genes can I use?

00:03:47.000 --> 00:03:49.000
This is exactly analogous to the question,

00:03:49.000 --> 00:03:50.000
what's the smallest program I can write

00:03:50.000 --> 00:03:52.000
that will act exactly like Microsoft Word?

00:03:52.000 --> 00:03:53.000
(Laughter)

00:03:53.000 --> 00:03:57.000
And just as he's writing, you know, bacteria that will be smaller,

00:03:57.000 --> 00:03:58.000
he's writing genomes that will work,

00:03:58.000 --> 00:04:00.000
we could write smaller programs

00:04:00.000 --> 00:04:02.000
that would do what Microsoft Word does.

00:04:02.000 --> 00:04:04.000
But for molecular programming, our question is,

00:04:04.000 --> 00:04:08.000
how many molecules do we need to put in that seed to get a cell phone?

00:04:08.000 --> 00:04:10.000
What's the smallest number we can get away with?

00:04:10.000 --> 00:04:12.000
Now, these are big questions in computer science.

00:04:12.000 --> 00:04:14.000
These are all complexity questions,

00:04:14.000 --> 00:04:16.000
and computer science tells us that these are very hard questions.

00:04:16.000 --> 00:04:18.000
Almost -- many of them are impossible.

00:04:18.000 --> 00:04:21.000
But for some tasks, we can start to answer them.

00:04:21.000 --> 00:04:22.000
So, I'm going to start asking those questions

00:04:22.000 --> 00:04:25.000
for the DNA structures I'm going to talk about next.

00:04:25.000 --> 00:04:28.000
So, this is normal DNA, what you think of as normal DNA.

00:04:28.000 --> 00:04:30.000
It's double-stranded, it's a double helix,

00:04:30.000 --> 00:04:33.000
has the As, Ts, Cs and Gs that pair to hold the strands together.

00:04:33.000 --> 00:04:35.000
And I'm going to draw it like this sometimes,

00:04:35.000 --> 00:04:37.000
just so I don't scare you.

00:04:37.000 --> 00:04:40.000
We want to look at individual strands and not think about the double helix.

00:04:40.000 --> 00:04:43.000
When we synthesize it, it comes single-stranded,

00:04:43.000 --> 00:04:46.000
so we can take the blue strand in one tube

00:04:46.000 --> 00:04:48.000
and make an orange strand in the other tube,

00:04:48.000 --> 00:04:50.000
and they're floppy when they're single-stranded.

00:04:50.000 --> 00:04:53.000
You mix them together and they make a rigid double helix.

00:04:53.000 --> 00:04:55.000
Now for the last 25 years,

00:04:55.000 --> 00:04:57.000
Ned Seeman and a bunch of his descendants

00:04:57.000 --> 00:05:00.000
have worked very hard and made beautiful three-dimensional structures

00:05:00.000 --> 00:05:03.000
using this kind of reaction of DNA strands coming together.

00:05:03.000 --> 00:05:06.000
But a lot of their approaches, though elegant, take a long time.

00:05:06.000 --> 00:05:09.000
They can take a couple of years, or it can be difficult to design.

00:05:09.000 --> 00:05:12.000
So I came up with a new method a couple of years ago

00:05:12.000 --> 00:05:13.000
I call DNA origami

00:05:13.000 --> 00:05:15.000
that's so easy you could do it at home in your kitchen

00:05:15.000 --> 00:05:17.000
and design the stuff on a laptop.

00:05:17.000 --> 00:05:20.000
But to do it, you need a long, single strand of DNA,

00:05:20.000 --> 00:05:22.000
which is technically very difficult to get.

00:05:22.000 --> 00:05:24.000
So, you can go to a natural source.

00:05:24.000 --> 00:05:26.000
You can look in this computer-fabricated artifact,

00:05:26.000 --> 00:05:28.000
and he's got a double-stranded genome -- that's no good.

00:05:28.000 --> 00:05:31.000
You look in his intestines. There are billions of bacteria.

00:05:31.000 --> 00:05:33.000
They're no good either.

00:05:33.000 --> 00:05:35.000
Double strand again, but inside them, they're infected with a virus

00:05:35.000 --> 00:05:38.000
that has a nice, long, single-stranded genome

00:05:38.000 --> 00:05:40.000
that we can fold like a piece of paper.

00:05:40.000 --> 00:05:41.000
And here's how we do it.

00:05:41.000 --> 00:05:42.000
This is part of that genome.

00:05:42.000 --> 00:05:45.000
We add a bunch of short, synthetic DNAs that I call staples.

00:05:45.000 --> 00:05:49.000
Each one has a left half that binds the long strand in one place,

00:05:49.000 --> 00:05:52.000
and a right half that binds it in a different place,

00:05:52.000 --> 00:05:54.000
and brings the long strand together like this.

00:05:55.000 --> 00:05:57.000
The net action of many of these on that long strand

00:05:57.000 --> 00:05:59.000
is to fold it into something like a rectangle.

00:05:59.000 --> 00:06:01.000
Now, we can't actually take a movie of this process,

00:06:01.000 --> 00:06:03.000
but Shawn Douglas at Harvard

00:06:03.000 --> 00:06:05.000
has made a nice visualization for us

00:06:05.000 --> 00:06:09.000
that begins with a long strand and has some short strands in it.

00:06:09.000 --> 00:06:13.000
And what happens is that we mix these strands together.

00:06:13.000 --> 00:06:15.000
We heat them up, we add a little bit of salt,

00:06:15.000 --> 00:06:17.000
we heat them up to almost boiling and cool them down,

00:06:17.000 --> 00:06:18.000
and as we cool them down,

00:06:18.000 --> 00:06:20.000
the short strands bind the long strands

00:06:20.000 --> 00:06:22.000
and start to form structure.

00:06:22.000 --> 00:06:25.000
And you can see a little bit of double helix forming there.

00:06:26.000 --> 00:06:28.000
When you look at DNA origami,

00:06:28.000 --> 00:06:31.000
you can see that what it really is,

00:06:31.000 --> 00:06:32.000
even though you think it's complicated,

00:06:32.000 --> 00:06:35.000
is a bunch of double helices that are parallel to each other,

00:06:35.000 --> 00:06:37.000
and they're held together

00:06:37.000 --> 00:06:39.000
by places where short strands go along one helix

00:06:39.000 --> 00:06:41.000
and then jump to another one.

00:06:41.000 --> 00:06:44.000
So there's a strand that goes like this, goes along one helix and binds --

00:06:44.000 --> 00:06:46.000
it jumps to another helix and comes back.

00:06:46.000 --> 00:06:48.000
That holds the long strand like this.

00:06:48.000 --> 00:06:51.000
Now, to show that we could make any shape or pattern

00:06:51.000 --> 00:06:53.000
that we wanted, I tried to make this shape.

00:06:54.000 --> 00:06:56.000
I wanted to fold DNA into something that goes up over the eye,

00:06:56.000 --> 00:06:59.000
down the nose, up the nose, around the forehead,

00:06:59.000 --> 00:07:02.000
back down and end in a little loop like this.

00:07:02.000 --> 00:07:05.000
And so, I thought, if this could work, anything could work.

00:07:05.000 --> 00:07:08.000
So I had the computer program design the short staples to do this.

00:07:08.000 --> 00:07:10.000
I ordered them; they came by FedEx.

00:07:10.000 --> 00:07:12.000
I mixed them up, heated them, cooled them down,

00:07:12.000 --> 00:07:16.000
and I got 50 billion little smiley faces

00:07:16.000 --> 00:07:18.000
floating around in a single drop of water.

00:07:18.000 --> 00:07:20.000
And each one of these is just

00:07:20.000 --> 00:07:24.000
one-thousandth the width of a human hair, OK?

00:07:24.000 --> 00:07:27.000
So, they're all floating around in solution, and to look at them,

00:07:27.000 --> 00:07:29.000
you have to get them on a surface where they stick.

00:07:29.000 --> 00:07:31.000
So, you pour them out onto a surface

00:07:31.000 --> 00:07:33.000
and they start to stick to that surface,

00:07:33.000 --> 00:07:35.000
and we take a picture using an atomic-force microscope.

00:07:35.000 --> 00:07:37.000
It's got a needle, like a record needle,

00:07:37.000 --> 00:07:39.000
that goes back and forth over the surface,

00:07:39.000 --> 00:07:42.000
bumps up and down, and feels the height of the first surface.

00:07:42.000 --> 00:07:44.000
It feels the DNA origami.

00:07:44.000 --> 00:07:46.000
There's the atomic-force microscope working

00:07:47.000 --> 00:07:48.000
and you can see that the landing's a little rough.

00:07:48.000 --> 00:07:50.000
When you zoom in, they've got, you know,

00:07:50.000 --> 00:07:51.000
weak jaws that flip over their heads

00:07:51.000 --> 00:07:54.000
and some of their noses get punched out, but it's pretty good.

00:07:54.000 --> 00:07:56.000
You can zoom in and even see the extra little loop,

00:07:56.000 --> 00:07:58.000
this little nano-goatee.

00:07:58.000 --> 00:08:01.000
Now, what's great about this is anybody can do this.

00:08:01.000 --> 00:08:05.000
And so, I got this in the mail about a year after I did this, unsolicited.

00:08:05.000 --> 00:08:08.000
Anyone know what this is? What is it?

00:08:08.000 --> 00:08:10.000
It's China, right?

00:08:10.000 --> 00:08:12.000
So, what happened is, a graduate student in China,

00:08:12.000 --> 00:08:14.000
Lulu Qian, did a great job.

00:08:14.000 --> 00:08:16.000
She wrote all her own software

00:08:16.000 --> 00:08:18.000
to design and built this DNA origami,

00:08:18.000 --> 00:08:21.000
a beautiful rendition of China, which even has Taiwan,

00:08:21.000 --> 00:08:24.000
and you can see it's sort of on the world's shortest leash, right?

00:08:24.000 --> 00:08:26.000
(Laughter)

00:08:27.000 --> 00:08:28.000
So, this works really well

00:08:29.000 --> 00:08:31.000
and you can make patterns as well as shapes, OK?

00:08:32.000 --> 00:08:35.000
And you can make a map of the Americas and spell DNA with DNA.

00:08:35.000 --> 00:08:38.000
And what's really neat about it --

00:08:38.000 --> 00:08:40.000
well, actually, this all looks like nano-artwork,

00:08:40.000 --> 00:08:41.000
but it turns out that nano-artwork

00:08:41.000 --> 00:08:43.000
is just what you need to make nano-circuits.

00:08:43.000 --> 00:08:45.000
So, you can put circuit components on the staples,

00:08:45.000 --> 00:08:47.000
like a light bulb and a light switch.

00:08:47.000 --> 00:08:50.000
Let the thing assemble, and you'll get some kind of a circuit.

00:08:50.000 --> 00:08:53.000
And then you can maybe wash the DNA away and have the circuit left over.

00:08:53.000 --> 00:08:55.000
So, this is what some colleagues of mine at Caltech did.

00:08:55.000 --> 00:08:58.000
They took a DNA origami, organized some carbon nano-tubes,

00:08:58.000 --> 00:09:00.000
made a little switch, you see here, wired it up,

00:09:00.000 --> 00:09:03.000
tested it and showed that it is indeed a switch.

00:09:03.000 --> 00:09:05.000
Now, this is just a single switch

00:09:05.000 --> 00:09:09.000
and you need half a billion for a computer, so we have a long way to go.

00:09:09.000 --> 00:09:11.000
But this is very promising

00:09:11.000 --> 00:09:16.000
because the origami can organize parts just one-tenth the size

00:09:16.000 --> 00:09:17.000
of those in a normal computer.

00:09:17.000 --> 00:09:20.000
So it's very promising for making small computers.

00:09:20.000 --> 00:09:23.000
Now, I want to get back to that compiler.

00:09:23.000 --> 00:09:26.000
The DNA origami is a proof that that compiler actually works.

00:09:27.000 --> 00:09:29.000
So, you start with something in the computer.

00:09:29.000 --> 00:09:32.000
You get a high-level description of the computer program,

00:09:32.000 --> 00:09:34.000
a high-level description of the origami.

00:09:34.000 --> 00:09:37.000
You can compile it to molecules, send it to a synthesizer,

00:09:37.000 --> 00:09:38.000
and it actually works.

00:09:38.000 --> 00:09:42.000
And it turns out that a company has made a nice program

00:09:42.000 --> 00:09:44.000
that's much better than my code, which was kind of ugly,

00:09:44.000 --> 00:09:45.000
and will allow us to do this in a nice,

00:09:45.000 --> 00:09:47.000
visual, computer-aided design way.

00:09:48.000 --> 00:09:49.000
So, now you can say, all right,

00:09:49.000 --> 00:09:51.000
why isn't DNA origami the end of the story?

00:09:51.000 --> 00:09:53.000
You have your molecular compiler, you can do whatever you want.

00:09:53.000 --> 00:09:56.000
The fact is that it does not scale.

00:09:56.000 --> 00:09:59.000
So if you want to build a human from DNA origami,

00:09:59.000 --> 00:10:01.000
the problem is, you need a long strand

00:10:01.000 --> 00:10:04.000
that's 10 trillion trillion bases long.

00:10:04.000 --> 00:10:06.000
That's three light years' worth of DNA,

00:10:06.000 --> 00:10:08.000
so we're not going to do this.

00:10:08.000 --> 00:10:10.000
We're going to turn to another technology,

00:10:10.000 --> 00:10:12.000
called algorithmic self-assembly of tiles.

00:10:12.000 --> 00:10:14.000
It was started by Erik Winfree,

00:10:14.000 --> 00:10:15.000
and what it does,

00:10:15.000 --> 00:10:19.000
it has tiles that are a hundredth the size of a DNA origami.

00:10:19.000 --> 00:10:21.000
You zoom in, there are just four DNA strands

00:10:22.000 --> 00:10:24.000
and they have little single-stranded bits on them

00:10:24.000 --> 00:10:26.000
that can bind to other tiles, if they match.

00:10:26.000 --> 00:10:29.000
And we like to draw these tiles as little squares.

00:10:30.000 --> 00:10:32.000
And if you look at their sticky ends, these little DNA bits,

00:10:32.000 --> 00:10:35.000
you can see that they actually form a checkerboard pattern.

00:10:35.000 --> 00:10:38.000
So, these tiles would make a complicated, self-assembling checkerboard.

00:10:38.000 --> 00:10:40.000
And the point of this, if you didn't catch that,

00:10:40.000 --> 00:10:43.000
is that tiles are a kind of molecular program

00:10:43.000 --> 00:10:46.000
and they can output patterns.

00:10:46.000 --> 00:10:48.000
And a really amazing part of this is

00:10:48.000 --> 00:10:50.000
that any computer program can be translated

00:10:50.000 --> 00:10:53.000
into one of these tile programs -- specifically, counting.

00:10:53.000 --> 00:10:56.000
So, you can come up with a set of tiles

00:10:56.000 --> 00:10:59.000
that when they come together, form a little binary counter

00:10:59.000 --> 00:11:01.000
rather than a checkerboard.

00:11:01.000 --> 00:11:04.000
So you can read off binary numbers five, six and seven.

00:11:04.000 --> 00:11:07.000
And in order to get these kinds of computations started right,

00:11:07.000 --> 00:11:09.000
you need some kind of input, a kind of seed.

00:11:09.000 --> 00:11:11.000
You can use DNA origami for that.

00:11:11.000 --> 00:11:13.000
You can encode the number 32

00:11:13.000 --> 00:11:15.000
in the right-hand side of a DNA origami,

00:11:15.000 --> 00:11:17.000
and when you add those tiles that count,

00:11:17.000 --> 00:11:20.000
they will start to count -- they will read that 32

00:11:20.000 --> 00:11:22.000
and they'll stop at 32.

00:11:22.000 --> 00:11:25.000
So, what we've done is we've figured out a way

00:11:25.000 --> 00:11:28.000
to have a molecular program know when to stop going.

00:11:28.000 --> 00:11:30.000
It knows when to stop growing because it can count.

00:11:30.000 --> 00:11:32.000
It knows how big it is.

00:11:32.000 --> 00:11:35.000
So, that answers that sort of first question I was talking about.

00:11:35.000 --> 00:11:38.000
It doesn't tell us how babies do it, however.

00:11:38.000 --> 00:11:42.000
So now, we can use this counting to try and get at much bigger things

00:11:42.000 --> 00:11:43.000
than DNA origami could otherwise.

00:11:43.000 --> 00:11:46.000
Here's the DNA origami, and what we can do

00:11:46.000 --> 00:11:49.000
is we can write 32 on both edges of the DNA origami,

00:11:49.000 --> 00:11:51.000
and we can now use our watering can

00:11:51.000 --> 00:11:55.000
and water with tiles, and we can start growing tiles off of that

00:11:55.000 --> 00:11:57.000
and create a square.

00:11:57.000 --> 00:12:00.000
The counter serves as a template

00:12:00.000 --> 00:12:02.000
to fill in a square in the middle of this thing.

00:12:02.000 --> 00:12:03.000
So, what we've done is we've succeeded

00:12:03.000 --> 00:12:06.000
in making something much bigger than a DNA origami

00:12:06.000 --> 00:12:09.000
by combining DNA origami with tiles.

00:12:09.000 --> 00:12:12.000
And the neat thing about it is, is that it's also reprogrammable.

00:12:12.000 --> 00:12:16.000
You can just change a couple of the DNA strands in this binary representation

00:12:16.000 --> 00:12:19.000
and you'll get 96 rather than 32.

00:12:19.000 --> 00:12:22.000
And if you do that, the origami's the same size,

00:12:22.000 --> 00:12:26.000
but the resulting square that you get is three times bigger.

00:12:27.000 --> 00:12:28.000
So, this sort of recapitulates

00:12:28.000 --> 00:12:30.000
what I was telling you about development.

00:12:30.000 --> 00:12:33.000
You have a very sensitive computer program

00:12:33.000 --> 00:12:36.000
where small changes -- single, tiny, little mutations --

00:12:36.000 --> 00:12:38.000
can take something that made one size square

00:12:38.000 --> 00:12:41.000
and make something very much bigger.

00:12:42.000 --> 00:12:45.000
Now, this -- using counting to compute

00:12:45.000 --> 00:12:47.000
and build these kinds of things

00:12:47.000 --> 00:12:49.000
by this kind of developmental process

00:12:49.000 --> 00:12:53.000
is something that also has bearing on Craig Venter's question.

00:12:53.000 --> 00:12:55.000
So, you can ask, how many DNA strands are required

00:12:55.000 --> 00:12:57.000
to build a square of a given size?

00:12:57.000 --> 00:13:02.000
If we wanted to make a square of size 10, 100 or 1,000,

00:13:02.000 --> 00:13:04.000
if we used DNA origami alone,

00:13:04.000 --> 00:13:07.000
we would require a number of DNA strands that's the square

00:13:07.000 --> 00:13:09.000
of the size of that square;

00:13:09.000 --> 00:13:11.000
so we'd need 100, 10,000 or a million DNA strands.

00:13:11.000 --> 00:13:13.000
That's really not affordable.

00:13:13.000 --> 00:13:15.000
But if we use a little computation --

00:13:15.000 --> 00:13:19.000
we use origami, plus some tiles that count --

00:13:19.000 --> 00:13:22.000
then we can get away with using 100, 200 or 300 DNA strands.

00:13:22.000 --> 00:13:27.000
And so we can exponentially reduce the number of DNA strands we use,

00:13:27.000 --> 00:13:30.000
if we use counting, if we use a little bit of computation.

00:13:30.000 --> 00:13:33.000
And so computation is some very powerful way

00:13:33.000 --> 00:13:36.000
to reduce the number of molecules you need to build something,

00:13:36.000 --> 00:13:39.000
to reduce the size of the genome that you're building.

00:13:39.000 --> 00:13:42.000
And finally, I'm going to get back to that sort of crazy idea

00:13:42.000 --> 00:13:44.000
about computers building computers.

00:13:44.000 --> 00:13:47.000
If you look at the square that you build with the origami

00:13:47.000 --> 00:13:49.000
and some counters growing off it,

00:13:49.000 --> 00:13:52.000
the pattern that it has is exactly the pattern that you need

00:13:52.000 --> 00:13:53.000
to make a memory.

00:13:53.000 --> 00:13:56.000
So if you affix some wires and switches to those tiles --

00:13:56.000 --> 00:13:59.000
rather than to the staple strands, you affix them to the tiles --

00:13:59.000 --> 00:14:02.000
then they'll self-assemble the somewhat complicated circuits,

00:14:02.000 --> 00:14:05.000
the demultiplexer circuits, that you need to address this memory.

00:14:05.000 --> 00:14:07.000
So you can actually make a complicated circuit

00:14:07.000 --> 00:14:09.000
using a little bit of computation.

00:14:09.000 --> 00:14:12.000
It's a molecular computer building an electronic computer.

00:14:12.000 --> 00:14:15.000
Now, you ask me, how far have we gotten down this path?

00:14:15.000 --> 00:14:18.000
Experimentally, this is what we've done in the last year.

00:14:18.000 --> 00:14:20.000
Here is a DNA origami rectangle,

00:14:21.000 --> 00:14:23.000
and here are some tiles growing from it.

00:14:23.000 --> 00:14:25.000
And you can see how they count.

00:14:25.000 --> 00:14:37.000
One, two, three, four, five, six, nine, 10, 11, 12, 17.

00:14:37.000 --> 00:14:41.000
So it's got some errors, but at least it counts up.

00:14:41.000 --> 00:14:42.000
(Laughter)

00:14:42.000 --> 00:14:45.000
So, it turns out we actually had this idea nine years ago,

00:14:45.000 --> 00:14:48.000
and that's about the time constant for how long it takes

00:14:48.000 --> 00:14:50.000
to do these kinds of things, so I think we made a lot of progress.

00:14:50.000 --> 00:14:52.000
We've got ideas about how to fix these errors.

00:14:52.000 --> 00:14:54.000
And I think in the next five or 10 years,

00:14:54.000 --> 00:14:56.000
we'll make the kind of squares that I described

00:14:56.000 --> 00:14:59.000
and maybe even get to some of those self-assembled circuits.

00:14:59.000 --> 00:15:03.000
So now, what do I want you to take away from this talk?

00:15:03.000 --> 00:15:05.000
I want you to remember that

00:15:05.000 --> 00:15:09.000
to create life's very diverse and complex forms,

00:15:09.000 --> 00:15:11.000
life uses computation to do that.

00:15:11.000 --> 00:15:15.000
And the computations that it uses, they're molecular computations,

00:15:15.000 --> 00:15:17.000
and in order to understand this and get a better handle on it,

00:15:17.000 --> 00:15:19.000
as Feynman said, you know,

00:15:19.000 --> 00:15:21.000
we need to build something to understand it.

00:15:21.000 --> 00:15:25.000
And so we are going to use molecules and refashion this thing,

00:15:25.000 --> 00:15:27.000
rebuild everything from the bottom up,

00:15:27.000 --> 00:15:30.000
using DNA in ways that nature never intended,

00:15:30.000 --> 00:15:32.000
using DNA origami,

00:15:32.000 --> 00:15:35.000
and DNA origami to seed this algorithmic self-assembly.

00:15:35.000 --> 00:15:37.000
You know, so this is all very cool,

00:15:38.000 --> 00:15:39.000
but what I'd like you to take from the talk,

00:15:39.000 --> 00:15:41.000
hopefully from some of those big questions,

00:15:41.000 --> 00:15:44.000
is that this molecular programming isn't just about making gadgets.

00:15:44.000 --> 00:15:46.000
It's not just making about --

00:15:46.000 --> 00:15:48.000
it's making self-assembled cell phones and circuits.

00:15:48.000 --> 00:15:50.000
What it's really about is taking computer science

00:15:50.000 --> 00:15:53.000
and looking at big questions in a new light,

00:15:53.000 --> 00:15:55.000
asking new versions of those big questions

00:15:55.000 --> 00:15:57.000
and trying to understand how biology

00:15:57.000 --> 00:15:59.000
can make such amazing things. Thank you.

00:16:00.000 --> 00:16:07.000
(Applause)

